Однострочные скрипты SED

http://system-administrators.info/?p=1751
English original http://www.ant0.ru/

Пространство между строками:

    Двойное пространство между строками:
        sed G
    Двойное пространство между строками исключая пустые строки (на выходе содержатся не больше одной пустой строки между двумя строками с текстом):
        sed '/^$/d;G'
    Тройное пространство между строками:
        sed 'G;G'
    Удалить каждую вторую строку:
        sed 'n;d'
    Вставить пустую строку перед каждой строкой соответствующей регулярному выражению "regex":
        sed '/regex/{x;p;x;}'
    Вставить пустую строку после каждой строки соответствующей регулярному выражению "regex":
        sed '/regex/G'
    Вставить пустую строку перед и после каждой строки соответствующей регулярному выражению "regex":
        sed '/regex/{x;p;x;G;}'

Нумерация:

    Нумерация каждой стоки в файле filename. Используя отступ (tab) (смотрите примечание по '\t' в конце документа) вместо пустой строки:
        sed = filename | sed 'N;s/\n/\t/'
    Нумерация каждой строки в файле filename (номер слева, выравненый по правому краю):
        sed = filename | sed 'N; s/^/ /; s/ *\(.\{6,\}\)\n/\1 /'
    Нумерация каждой строки в файле filename, с выводом номера только для не пустых строк:
        sed '/./=' filename | sed '/./N; s/\n/ /'
    Подсчет строк (эмуляция "wc -l"):
        sed -n '$='

Преобразование и замена текста:

    В UNIX окружении: преобразование окончания строк из формата DOS (CR/LF) в формат Unix (LF):
        sed 's/.$//' (подразумевается что все строки заканчиваются с CR/LF)
        sed 's/^M$//' (в bash/tcsh, нажмите Ctrl-V затем Ctrl-M)
        sed 's/\x0D$//' (работает в ssed, gsed 3.02.80 или выше)
    В UNIX окружении: преобразование разрыва строк Unix (LF) в формат DOS:
        sed "s/$/`echo -e \\\r`/" (команда в ksh)
        sed 's/$'"/`echo \\\r`/" (команда под bash)
        sed "s/$/`echo \\\r`/" (команда под zsh)
        sed 's/$/\r/' (команда под gsed 3.02.80 или выше)
    В DOS окружении: преобразование разрыва строк Unix (LF) в формат DOS:
        Версия 1: sed "s/$//"
        Версия 2: sed -n p
    В DOS окружении: преобразование разрыва строк DOS (CR/LF) в формат Unix. Работоет только с sed версии 4.0.7 или выше. Версию в Unix окружении можно узнать, вызвав SED с параметром "--version". В версии ниже, в DOS окружении такой фокус не пройдет. Использвйте взамен комманду "tr":
        sed "s/\r//" infile >outfile (sed v4.0.7 или выше)
        tr -d \r <infile >outfile (GNU tr версии 1.22 или выше)
    Удалить все пробелы и символы табуляции в начале каждой строки файла (смотрите примечание по табуляции в конце документа):
        sed 's/^[ \t]*//'
    Удалить все пробелы и символы табуляции в конце каждой строки файла (смотрите примечание по табуляции в конце документа):
        sed 's/[ \t]*$//'
    Удалить все пробелы и символы табуляции в начале и конце каждой строки файла (смотрите примечание по табуляции в конце документа):
        sed 's/^[ \t]*//;s/[ \t]*$//'
    Вставить 5 пробелов в начале каждой строки (создать смещение страницы):
        sed 's/^/ /'
    Расположить весь текст по правому краю столбца шириной в 79 символов:
        sed -e :a -e 's/^.\{1,78\}$/ &/;ta' (устанавливает как 78 плюс 1 пробельный символ)
    Центрировать весь текст посередине столбца шириной 79 символов. В версии 1, пробелы добовляются в начало и конец строки. В версии 2, пробелы добовляются только в начало строки:
        Версия 1: sed -e :a -e 's/^.\{1,77\}$/ & /;ta'
        Версия 2: sed -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'
    Поиск и замеа "foo" на "bar" в каждой строке:
        sed 's/foo/bar/' (замена только первого совпадения в строке)
        sed 's/foo/bar/4' (замена первых 4рех совпадений в строке)
        sed 's/foo/bar/g' (замена ВСЕХ совпадений в строке)
        sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' (замена предпоследнего совпадения)
        sed 's/\(.*\)foo/\1bar/' (замена только последнего совпадения)
    Замена "foo" на "bar" ТОЛЬКО для строк содержащих "baz":
        sed '/baz/s/foo/bar/g'
    Замена "foo" на "bar" ИСКЛЮЧАЯ строки содержащие "baz":
        sed '/baz/!s/foo/bar/g'
    Замена "scarlet" или "ruby", или "puce" на "red":
        sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g' (большинство sed-ов)
        gsed 's/scarlet\|ruby\|puce/red/g' (только GNU sed)
    Перевернуть последовательность строк (эмуляция "tac") (ошибка/особеннось в HHsed v1.5 причина удалению пустой строки):
        Версия 1: sed '1!G;h;$!d'
        Версия 2: sed -n '1!G;h;$p'
    Перевернуть каждую строку в файле задом наперед (эмуляция "rev"):
        sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'
    Соеденить каждую пару строк бок о бок (подобно "paste"):
        sed '$!N;s/\n/ /'
    Если линия заканчивается обратной косой чертой "\", то присоеденить следующую линию:
        sed -e :a -e '/\\$/N; s/\\\n//; ta'
    Если линия начинается с знака "=", то присоеденить ее к предыдущей линии и заменить "=" пробелом:
        sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'
    Добавить запятые к строке из чисел, изменяя "1234567" на "1,234,567":
        gsed ':a;s/\B[0-9]\{3\}\>/,&/;ta' (GNU sed)
        sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' (другие sed-ы)
    Добавить запятые к числу с десятичной частью и знаком минуса (GNU sed):
        gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'
    Добавить пустую строку через каждые 5 строк (после строк 5, 10, 15, 20, и т.д.):
        gsed '0~5G' (только GNU sed)
        sed 'n;n;n;n;G;' (другие sed-ы)

Выборочная печать некоторых строк:

    Печатать первые 10 линий файла (эмуляция "head"):
        sed 10q
    Печатать первую строку файла (эмуляция "head -1"):
        sed q
    Печатать последние 10 строк файла (эмуляция "tail"):
        sed -e :a -e '$q;N;11,$D;ba'
    Печатать последние 2 строки файла (эмуляция "tail -2"):
        sed '$!N;$!D'
    Печатать последнюю строку файла (эмуляция "tail -1"):
        Версия 1: sed '$!d'
        Версия 2: sed -n '$p'
    Печатать предпоследнюю строку в файле:
        sed -e '$!{h;d;}' -e x (для однострочного файла печатать пустую строку)
        sed -e '1{$q;}' -e '$!{h;d;}' -e x (для однострочного файла печатать эту строку)
        sed -e '1{$d;}' -e '$!{h;d;}' -e x (для однострочного файла ничего не печатать)
    Печатать только те строки, которые совпадают с регулярным выражением (эмуляция "grep"):
        Версия 1: sed -n '/regexp/p'
        Версия 2: sed '/regexp/!d'
    Печатать только те строки, которые НЕ совпадают с регулярным выражением (эмуляция "grep -v"):
        sed -n '/regexp/!p' - Версия 1, corresponds to above
        sed '/regexp/d' - Версия 2, simpler syntax
    Печатать строку непосредственно перед регулярным выражением, но не печатать строку содержащую регулярное выражение:
        sed -n '/regexp/{g;1!p;};h'
    Печатать строку непосредственно после регулярного выражения, но не печатать строку содержащую регулярное выражение:
        sed -n '/regexp/{n;p;}'
    Печатать по одной строке перед и после регулярного выражения, с указанием номера строки совпадающей с регулярным выражением (симуляция "grep -A1 -B1"):
        sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h
    Печать строк, совпадающих с регулярными выражениями AAA, BBB и CCC одновременно (в любой последовательности):
        sed '/AAA/!d; /BBB/!d; /CCC/!d'
    Печать строк, совпадающих с регулярными выражениями AAA, BBB и CCC одновременно (в конкретной последовательности):
        sed '/AAA.*BBB.*CCC/!d'
    Печать строк, совпадающих с любым регулярным выражением AAA или BBB, или CCC (эмуляция "egrep"):
        sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d (большинство sed'ов)
        gsed '/AAA\|BBB\|CCC/!d' (только GNU sed)
    Печатать абзац если он содержит AAA (пустая строка разделяет абзацы) (в HHsed v1.5 необходимо вставить 'G;' после 'x;'):
        sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'
    Печатать абзац если он содержит AAA, BBB и CCC (в любой последовательности) (в HHsed v1.5 необходимо вставить 'G;' после 'x;'):
        sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'
    Печатать абзац если он содержит AAA или BBB, или CCC (в HHsed v1.5 необходимо вставить 'G;' после 'x;'):
        sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
        gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d' (только GNU sed)
    Печатать строки длиной равной или большей 65 символов:
        sed -n '/^.\{65\}/p'
    Печатать строки длиной меньше или равной 65 символов:
        sed -n '/^.\{65\}/!p' - Версия 1, отвечает условию
        sed '/^.\{65\}/d' - Версия 2, более простой синтаксис
    Печатать часть файла начиная от совпадения с регулярным выражением и до конца файла:
        sed -n '/regexp/,$p'
    Печатать часть файла основываясь на номерах строк (строки 8-12, включительно):
        Версия 1: sed -n '8,12p'
        Версия 2: sed '8,12!d'
    Печатать строку под номером 52:
        sed -n '52p' - Версия 1
        sed '52!d' - Версия 2
        sed '52q;d' - Версия 3, эффективен на больших файлах
    Начиная с 3ей строки печатать каждую седьмую строку в файле:
        gsed -n '3~7p' (только GNU sed)
        sed -n '3,${p;n;n;n;n;n;n;}' (другие sed-ы)
    Печатать часть файла между двумя регулярными выражениями (включительно):
        sed -n '/Iowa/,/Montana/p' (регистро зависимый)

Избирательное удаление определенных строк:

    Печатать все линии ИСКЛЮЧАЯ часть между двумя регулярными выражениями:
        sed '/Iowa/,/Montana/d'
    Удалить дубликаты последовательных строк в файле (эмуляция "uniq"). Первая строка в наборе дубликатах строк удерживается от удаления:
        sed '$!N; /^\(.*\)\n\1$/!P; D'
    Удалить дубликаты непоследовательных строк в файле. Остерегайтесь переполнения буфера или используйте GNU sed:
        sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'
    Печатать только дубликаты строк (эмуляция "uniq -d"):
        sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'
    Удалить первые 10 строк в файле:
        sed '1,10d'
    Удалить последнюю строку в файле:
        sed '$d'
    Удалить 2 последние строки файла:
        sed 'N;$!P;$!D;$d'
    Удалить последние 10 строк файла:
        Версия 1: sed -e :a -e '$d;N;2,10ba' -e 'P;D'
        Версия 2: sed -n -e :a -e '1,10!{P;N;D;};N;ba'
    Удалить каждую восьмую строку в файле:
        gsed '0~8d' (только GNU sed)
        sed 'n;n;n;n;n;n;n;d;' (другие sed-ы)
    Удалить строки совпадающие с регулярным выражением:
        sed '/pattern/d'
    Удалить ВСЕ пустрые строки из файла (эмуляция "grep '.' "):
        Версия 1: sed '/^$/d'
        Версия 2: sed '/./!d'
    Удалить все последовательности пустых строк из файла исключая первую. Также удалить все пустые строки в начале и в конце файла (эмуляция "cat -s"):
        sed '/./,/^$/!d' (Версия 1, допускается 0 пустых строк в начале и 1 в конце файла)
        sed '/^$/N;/\n$/D' (Версия 2, допускается 1 пустая строка в начале и 0 в конце файла)
    Оставить последовательность пустых строк не более двух одновременно:
        sed '/^$/N;/\n$/N;//D'
    Удалить все пустые строки в начале файла:
        sed '/./,$!d'
    Удалить все пустые строки в конце файла:
        sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' (для всех sed-ов)
        sed -e :a -e '/^\n*$/N;/\n$/ba' (для всех, кроме gsed 3.02.*)
    Удалить последнюю непустую строку в каждом абзаце:
        sed -n '/^$/{p;h;};/./{x;/./p;}'

Специальные приложения:

    Получить заголовок Usenet/e-mail сообщения:
        sed '/^$/q' (удаляет все после первой пустой строки)
    Получить тело Usenet/e-mail сообщений:
        sed '1,/^$/d' (удаляет все до первой пустой строки)
    Получить заголовок Subject (тема Usenet/e-mail сообщения), без удаления части "Subject: ":
        sed '/^Subject: */!d; s///;q'
    Получить заголовок обратный адрес:
        sed '/^Reply-To:/q; /^From:/h; /./d;g;q'
    Анализировать правильный исходящий адрес. # Pulls out the e-mail address by itself from the 1-line return address header (see preceding script):
        sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'
    Добавить скобку и пробел в начало каждой строки (цитирование сообщения):
        sed 's/^/> /'
    Удалить скобку и пробел в начале каждой строки (unquote a message):
        sed 's/^> //'
    Удалить большинство HTML тегов (включая теги состоящие из несколько строк):
        sed -e :a -e 's/<[^>]*>//g;/</N;//ba'
    Извлечение закодированных (uuencoded) двоичных данных из нескольких частей, удаление внешней заголовочной информации. Итак это только часть закодированного остатка. Файлы пропущенные через sed должны быть пропущены в правильной последовательности. Версия 1 может быть введена из командной строки, версия 2 может быть встроена в исполняемый скрипт оболочки Unix. (Модифицированна из скрипта Rahul Dhesi):
        Версия 1: sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode
        Версия 2: sed '/^end/,/^begin/d' "$@" | uudecode
    Отсортировать абзацы файла в алфавитном порядке. Абзацы разделены пустой строкой. GNU sed использует \v для вертикального выравнивания, или это может быть любой уникальный символ:
        sed '/./{H;d;};x;s/\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
        gsed '/./{H;d};x;y/\n/\v/' file | sort | sed '1s/\v//;y/\v/\n/'
    Удалить конкретный символ (к примеру: символ возврата) из man страницы. Для использования команды 'echo' может потребоваться указать параметр -e (если вы используете Unix System V или оболочку bash):
        sed "s/.`echo \\\b`//g" (двойные кавычки необходимы в Unix окружении)
        sed 's/.^H//g' (в bash/tcsh, нажмите Ctrl-V и затем Ctrl-H)
        sed 's/.\x08//g' (hex выражение для sed 1.5, GNU sed, ssed)
    В DOS окружении: создаем коммандный файл, который запаковывает каждый txt-файл в каталоге (в две команды):
        echo @echo off >zipup.bat
        dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat

Типичное использование:

sed берет одну или более команд редактирования и в результате примеяет их все к каждой входящей строке. После этого все команды будут применены к первой входящей строке, эта строка выводится, а следующая входящая строка берется для обработки и цикл повтаряется.
Предшествующий пример предполагает что данные поступают с устройства стандартного ввода (например, консоль - стандартный канал ввода). Один или больше имен файлом могут быть присоеденены к командной строке если вход идет не из stdin. Вывод отсылается на стандартный вывод (stdout - обычно экран).

Так:

    cat filename | sed '10q' (используется ввод из конвеера)
    sed '10q' filename (тот же эффект, исключая использование "cat")
    sed '10q' filename > newfile (перенаправление вывода в файл)

Для дополнительных синтаксических инструкций, включая метод применения команд редактирования из файла, взамен командной строки, посмотрите книги Dale Dougherty и Arnold Robbins "sed & awk, 2nd Edition,", "UNIX Text Processing," by Dale Dougherty и Tim O'Reilly (Hayden Books, 1987) или учебники Mike Arst distributed in U-SEDIT2.ZIP (many sites).

Для использование всех возможностей sed-а вы должны понимать "регулярные выражения". Для этого смотрите "Mastering Regular Expressions" by Jeffrey Friedl (O'Reilly, 1997).

Могут пригодиться страницы руководства ("man") в системе Unix (Используйте "man sed", "man regexp", или раздел по регулярным выраженям в "man sed"), но страницы руководства, как правило, трудны. Они не написаны для обучения пользователей использования sed-а или регулярных выражений с нуля, а написаны как справочник для тех кто уже умеет работать с этими инструментами.
Цитирование правил (Quoting syntax):

Предшествующий пример использует одинарные кавычки ('...') вместо двойных кавычек ("...") для окружения редактируемой команды, с тех пор как sed в основном исользуется на платформах Unix. Одинарные кавычки предотращают оболочку Unix от интерпретации знака доллара ($) и обратных кавычек (`...`), которые расширяют оболочку если они заключены в двойные кавычки. Пользователи "csh" shell и происходящие от нее оболочки, также нуждаются в взятие в кавычки знака восклицания (!). С обратной косой чертой (\!) правильно запускает пример указанные выше, даже внутри одинарных кавычек.

Версии sed написанные для DOS обязательно требуют заключение редактируемых команд в двойные кавычки ("...") взамен одинарных.
Исользование '\t' в скриптах SED:

Для ясности документации, мы можем использовать выражение '\t' для обозначения символа табуляции (0x09) в скриптах.

Однако большинство версий sed-а не понимают сокращение '\t', чтобы ввести этот символ из командной строки, введите его клавишей "TAB".

'\t' поддерживается как метасимвол регулярнго выражения в awk, perl, HHsed, sedmod, и GNU sed v3.02.80.
Версии sed:

Разные версии sed-а, различаются незначителными переменами. Большинство версий не поддерживает меток (:name) или ветвление инструкций (b,t) внутри команд редактирования. Хотя поддерживают их в конце команд. Желательно использовать синтаксис исключая метки и ветвления инструкций, несмотря на популярность GNU версии sed-а, позволяющий более краткий и красивый синтаксис.

Когда читатель смотрит GNU версию sed-а, поддерживающего боле лаконичный синтаксис и видит такую длинную команду, как эту:

    sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

это подбивает к изученю GNU версию sed-а, для укорачивания команды:

    sed '/AAA/b;/BBB/b;/CCC/b;d'
    sed '/AAA\|BBB\|CCC/b;d'

В дополнение запомните: многие версии sed-а принимают команду, типа "/one/ s/RE1/RE2/", но не принимают типа "/one/! s/RE1/RE2/" - содержащую пробел перед "s".
Оптимизация по скорости:

Для необходимого ускорения выполнения программы (к примеру на больший файлах, медленном процессоре или медленном носителе), замена будет более быстрой если искомое условие будет продублированно перед инструкцией "s/.../.../". Пример:

    sed 's/foo/bar/g' filename (стандартная команда замены)
    sed '/foo/ s/foo/bar/g' filename (выполняется быстрее)
    sed '/foo/ s//bar/g' filename (укороченный синтаксис предыдущей команды)

В однострочном выводе на печать или удалении строк (при неполной обработке файла), используйте команду выхода "quit" (q) в скрипте - это резко сократит время обработки больших файлов. Пример:

    sed -n '45,50p' filename (вывести на печатать линии с 45 по 50)
    sed -n '51q;45,50p' filename (тоже самое, но работает быстрее)

Если Вы хотите добавить свой скрипт или нашли ошибку в этом документе, пожалуйста отправьте e-mail составителю. Также укажите составителю используемую Вами версию sed-а, операционную систему составителю и обозначьте проблему. Чтобы охарактеризовать скрипт как одно-строковый, команда должна содержать не больше 65 символов.

Разнообразные скрипты в этом документе были написаны (или содействовали):

    Al Aab - founder of "seders" list
    Edgar Allen - various
    Yiorgos Adamopoulos - various
    Dale Dougherty - author of "sed & awk"
    Carlos Duarte - author of "do it with sed"
    Eric Pement - author of this document
    Ken Pizzini - author of GNU sed v3.02
    S.G. Ravenhall - great de-html script
    Greg Ubben - many contributions & much help

Переведено: Anton Tarasov
