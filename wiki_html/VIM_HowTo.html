<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>VIM How to</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>


<p>
<strong>VIM Howto</strong>
<div class="toc">
<ul>
<li><a href="#toc_1">Installation</a>
<ul>
<li><a href="#toc_1.1">Binary</a>
<li><a href="#toc_1.2">Add plugins</a>
</ul>
<li><a href="#toc_2">Saving</a>
<li><a href="#toc_3">Open files and buffers</a>
<li><a href="#toc_4">Tab mappings</a>
<li><a href="#toc_5">Windows and Tabs</a>
<li><a href="#toc_6">Syntax</a>
<li><a href="#toc_7">Spelling</a>
<li><a href="#toc_8">Color schema</a>
<li><a href="#toc_9">Insert mode</a>
<li><a href="#toc_10">Movements</a>
<ul>
<li><a href="#toc_10.1">motions</a>
<li><a href="#toc_10.2">:marks</a>
<li><a href="#toc_10.3">:jumps</a>
<li><a href="#toc_10.4">:changes</a>
</ul>
<li><a href="#toc_11">Searching and Substitutions</a>
<ul>
<li><a href="#toc_11.1">Search settings</a>
<li><a href="#toc_11.2">Searching</a>
<li><a href="#toc_11.3">Substitutions</a>
<li><a href="#toc_11.4">Grep</a>
<li><a href="#toc_11.5">Regular expression syntax style</a>
<li><a href="#toc_11.6">Action with searching</a>
</ul>
<li><a href="#toc_12">Mapping and abbreviation</a>
<li><a href="#toc_13">Foldings</a>
<li><a href="#toc_14">Diff</a>
<li><a href="#toc_15">Registers</a>
<li><a href="#toc_16">Text formating</a>
<li><a href="#toc_17">Command mode</a>
<li><a href="#toc_18">Help and refrences</a>
<li><a href="#toc_19">Programming</a>
<ul>
<li><a href="#toc_19.1">VIM-FUGITIVE (plugin)</a>
</ul>
<li><a href="#toc_20">TODO</a>
</ul>
</div>
</p>

<h1 id="toc_1">Installation</h1>

<p>
Install ruby and ruby-dev beforehand if needed.
</p>

<h2 id="toc_1.1">Binary</h2>
<pre sh>
mkdir ~/src
cd ~/src
wget http://ftp.vim.org/pub/vim/unix/vim-7.3.tar.bz2
tar -xaf vim-7.3.tar.bz2
cd vim73
./configure --with-features=huge --enable-perlinterp --enable-rubyinterp --enable-pythoninterp
make
make install
vim --version
</pre>
<p>
--prefix={directory}  Top directory where to install Vim. Default is /usr/local
</p>

<h2 id="toc_1.2">Add plugins</h2>
<ul>
<li>
The NERD tree   : A tree explorer plugin for navigating the file system

<li>
project.tar.gz  : Organize/Navigate projects of files (like IDE/buffer explorer) 

<li>
LustyExplorer  : Dynamic file system and buffer explorer # This plugin requires Vim be compiled with Ruby interpretation.

<li>
FuzzyFinder    : Buffer/file/command/tag/etc explorer with fuzzy matching 

<li>
bufexplorer.zip : Buffer Explorer / Browser 

<li>
taglist.vim     : Source code browser (supports C/C++, java, perl, python, tcl, sql, php, etc) 

<li>
ack.vim         : Plugin for the Perl module / CLI script 'ack' 

</ul>

<h1 id="toc_2">Saving</h1>
<pre>
:w
:w!             # only if permissions allow
:w !sudo tee %  # write as a root
:update         # write only if changed
ZZ              # save file, if modified, and quit (same as ":x")
ZQ              # quit without saving (same as ":q!")
:1,10 w outfile    # Saves lines 1 to 10 in outfile
:1,10 w &gt;&gt; outfile # Appends lines 1 to 10 to outfile
</pre>

<h1 id="toc_3">Open files and buffers</h1>
<pre>
:e filename  # open file in current window
:e .         # browse dir
:ls          # buffers
:bd          # delete (close) buffer
&lt;Ctr&gt;^       # alternative buffer (previous or useful file from plugin)
:b name      # switch to buffer (try TAB and arrows as well)
:b3          # switch to buffer number 3
:bp          # previous buffer
:bn          # next buffer
:bf          # first buffer 
:bl          # last buffer
:ba          # open a window for every buffer (buffer all)
:tab ba      # open a tab for every buffer (buffer all)
:set hidden  # lets hide buffer without saving

:set wildmode=list,full                               # see :h wildmode for details
:e scp://my_user@remote_hostname//path/to/remote/file # open remote file

:bufdo {cmd} # execute {cmd} for each buffers in the buffer list
:windo {cmd} # execute {cmd} for each windows in the current tab page
:tabdo {cmd} # execute {cmd} for each current window of each tab page
:argdo {cmd} # execute {cmd} for each file in the argument list
:r infile    # insert the content of infile
:r !{cmd}    # execute {cmd} and insert its standard output below
</pre>

<h1 id="toc_4">Tab mappings</h1>
<pre>
map &lt;leader&gt;tt :tabnew&lt;cr&gt;        :tabnew                " open a new tab
map &lt;leader&gt;te :tabedit	          :tabe[dit] {file}      " edit {file} in a new tab
map &lt;leader&gt;tc :tabclose&lt;cr&gt;      :tabc[lose]            " close the current tab
map &lt;leader&gt;to :tabonly&lt;cr&gt;       :tabo[nly]             " close the other tabs
map &lt;leader&gt;tn :tabnext&lt;cr&gt;       :tabn[ext]             " go to the next tab
map &lt;leader&gt;tp :tabprevious&lt;cr&gt;   :tabp[revious]         " go to the previous tab
map &lt;leader&gt;tf :tabfirst&lt;cr&gt;      :tabfir[st]            " go to the first tab
map &lt;leader&gt;tl :tablast&lt;cr&gt;       :tabl[ast]             " go to the last tab
map &lt;leader&gt;tm :tabmove	          :tabm[ove] 3           " move the current tab to after tab 3, or the end if no number is given
               :tabs                                     " list the tabs and their windows
</pre>

<h1 id="toc_5">Windows and Tabs</h1>
<pre>
^Ww          # next window.
^WT          # move window to the new tab.
^Wc          # close window.
^Wo          # only this window.
^Wr          # rotate windows.
^Ws          # split windows.
^Wv          # vsplit windows.
^Wx          # swap windows.
^w+          # larger window
^w-          # smaller window
^w=          # equal window
:sp f        # split open f
:vsp f       # vSplit open f
:vert h help # open help in vertical split.
:ta b all    # open all args (input files) in new tabs.
:ta b ball   # open all buffers in new tabs.
:tabm [N]    # move current tab after tab N. No N: last. N=0: first.
$vim -p file1 file2 fileN  # Open multiple files in different tabs.
</pre>

<h1 id="toc_6">Syntax</h1>
<pre>
:syntax enable
:set syntax=perl #force perl syntax on any file type
</pre>

<h1 id="toc_7">Spelling</h1>
<pre>
:set spell
z=       # Suggestions
1z=      # Except the first suggestion
[s       # Next wrong word
]s       # Previous wrong word
zg       # Add as good 
zw       # Add as wrong
zug      # Undo adding as good
zuw      # Undo adding as wrong
</pre>

<p>
In order to spell check in comments and strings switch off the syntax
</p>
<pre>
:syntax off
:syntax on
</pre>

<h1 id="toc_8">Color schema</h1>
<ul>
<li>
emacs.vim

<li>
far.vim

<li>
murphy.vim

<li>
topfunky-light.vim

<li>
vividchalk.vim

<li>
wombat.vim

</ul>

<h1 id="toc_9">Insert mode</h1>
<pre>
I i a A
r R               # backspace will restore the original
cc = C            # change to the end of line
xJ xgJ            # join x lines with/without spaces
x&lt;&lt; x&gt;&gt;           # indent in normal mode
Cntr-t -d         # indent in insert mode
gp                # just like "p", but leave the cursor just after the new text
set tabstop=4
set shiftwidth=4
set expandtab
</pre>
<p>
#vit = {change, delete, yank, visual} + {all, inner} + {word, Word, sentence, paragraph, tag, ", ', [, {, (}
</p>

<h1 id="toc_10">Movements</h1>

<h2 id="toc_10.1">motions</h2>
<pre>
0 g0 ^ g^ gE B ge b h gm | l w W e E g$ $
, Fx Tx fx Tx  ;
gg xH { ( gk - k M j + gj ) } xL G          # 12gg = 12G
Ctrl-b Ctrl-u Ctrl-y Ctrl-e Ctrl-d Ctrl-f
zt (z Enter) zz zb # set scrolloff=3 to have some extra lines for a lookup
zH zh zl zL
gCtrl-g # where am I? also set ruler set number set laststatus=2
</pre>
<p>
When a motion is not of the type you would like to use, you can force another
type by using "v", "V" or CTRL-V just after the operator.
</p>

<h2 id="toc_10.2">:marks</h2>
<pre>
ma `a 'a # local marks used for navigation and block editing
mA `A 'A # global marks can be used as short cuts to often used files
`0-`9    # most recent exited files
]'  ['   # [count] times to next/previous line with a lowercase mark below
]`  [`   # [count] times to lowercase mark after/before the cursor. 
`"       # [count] times to lowercase mark before the cursor.
</pre>

<h2 id="toc_10.3">:jumps</h2>
<p>
A "jump" is one of the following commands: "'", "`", "G", "/", "?", "n",
"N", "%", "(", ")", "]]", "[[", "{", "}", ":s", ":tag", "L", "M", "H" and
the commands that start editing a new file.
</p>
<pre>
'' ``    # latest jump
^O       # older cursor position in jump list (not a motion command)
^I       # newer cursor position in jump list (not a motion command)
&lt;Tab&gt;    # newer cursor position in jump list (not a motion command)
%        # jump to match, also see plugins
o O      # jump in visual mode to the other end of selection
`"       # jump to position on which we were when exited current buffer last time. 
`0       # jump to position in last file edited (when exited Vim)
`1       # like `0 but the previous file (also `2 etc)
</pre>

<h2 id="toc_10.4">:changes</h2>
<pre>
'. `.    # latest edit
gi       # latest edit and insert
`[ `]    # jump to the first/last character of the previously changed or yanked text. 
'[  ']   # jump to the first/last line of the previously changed or yanked text. 
`&lt; `&gt;    # jump to beginning/end of last visual selection
g;       # older cursor position in change list (not a motion command)
g,       # newer cursor position in change list (not a motion command)
</pre>

<h1 id="toc_11">Searching and Substitutions</h1>

<h2 id="toc_11.1">Search settings</h2>
<pre>
:set hlsearch
:set incsearch
:set number
</pre>

<h2 id="toc_11.2">Searching</h2>
<pre>
g# # N ? / n * g*

]I                   # list lines in current and included files that contain the word under cursor, 
[I                   # start searching at cursor position the cursor/beginning of current file.
gd gD                # find local/global declaration
/pattern/+           # next line
/pattern/+x          # x lines after
/pattern/e+x         # x characters after
/\&lt; the\&gt;            # search the
/^\n\{3}             # find 3 empty lines
:bufdo /searchstr/   # search in all open files
</pre>

<h2 id="toc_11.3">Substitutions</h2>
<pre>
:[range] s/pattern/string/[flags] [count]  # substitute
   #flags g, c, i, I
   #ranges , joins ; separates, also use visual
   empty             # current line
   %                 # all buffer
   +x -x             # x lines up/down
   1                 # first line
   $                 # last line
   't                # mark 't
   /pat/             # pattern
   #count            # only in the next x lines
   /\cpatter         # case insensitive
   /\Cpatter         # case sensitive
</pre>
<pre>
:%s/\&lt;./\u&amp;/g        # Sets first letter of each word to uppercase
:%s/\&lt;./\l&amp;/g        # Sets first letter of each word to lowercase
:%s/.*/\u&amp;           # Sets first letter of each line to uppercase
:%s/.*/\l&amp;           # Sets first letter of each line to lowercase
</pre>

<h2 id="toc_11.4">Grep</h2>
<pre>
:[range] g/pattern/[cmd] #search and execute
   #                 # show lines with numbers
   d                 # delete lines
   y                 # yank lined
   /normal {command} # execute an extended sequence, examples:
          :g/^$/d                               delete empty lines
          :g/pat/+ y                            copy lines after match
          :.,+10g/pat/d                         delete lines with pat within next 10 lines
          :.,'f+2g/pat/#                        show lines with pat from here to mark f +2 lines
          :.,/pat1/g/pat2/d                     delete lines with pat1 from here to line with pat2
          :g/^sub /normal O# This sub is for    adds this line before all sub definitions
          :g/pat                                list all lines that have pat
Tip: last search is in register /. To copy it into command: &lt;Ctrl-r&gt;/. So firstly tune your search with inc-search and then copy it to g/&lt;Ctrl-r/d
</pre>

<h2 id="toc_11.5">Regular expression syntax style</h2>
<pre>
\v      # very magic =~ Perl = Unix Egrep, but '=' is 0 or 1 match (in Perl it is '?')  /\v(.y){3}
\m      # magic = default = Unix grep =&gt; \( \) \+ \= *   /\(.y\)\{3}
</pre>

<h2 id="toc_11.6">Action with searching</h2>
<pre>
#vit = {change, delete, yank, visual} + {?pat,/pat} + {?+,?+x,?-,?-x,/+,... }

:%perldo s/this/that/ # execs that perl s///
</pre>

<h1 id="toc_12">Mapping and abbreviation</h1>
<pre>
map namp imap vmap map!
:map :vmap :map &gt;               # show current mappings all/ for &gt; only
:vumap &gt; :unmap &gt;               # unmap &gt;
:vmap &gt; &gt;gv                     # indent block without losing selection
:vmap &lt; &lt;gv
:vmap &lt;Tab&gt; &gt;gv
:vmap &lt;S-Tab&gt; &lt;gv
:imap &lt;Tab&gt; &lt;C-N&gt;
:imap &lt;S-Tab&gt; &lt;C-P&gt;
:nnoremap ; :                   # swapping keys
:nnoremap : ;
:let mapleader=","              # change the personal hotkey
:imap &lt;Leader&gt;f &lt;Esc&gt;gUiw`]a    # capitalize current word in insert mode

:ab ff FireFox                  # insert, command and replace mode
</pre>
<p>
To avoid the abbreviation in insert mode: Type part of the abbreviation, exit
insert mode with &lt;Esc&gt;, re-enter insert mode with "a" and type the rest.  Or
type CTRL-V before the character after the abbreviation.
To avoid the abbreviation in Command-line mode: Type CTRL-V twice somewhere in
the abbreviation to avoid it to be replaced.  A CTRL-V in front of a normal
character is mostly ignored otherwise.
</p>
<pre>
Remap CapsLock to Ctrl: in Windows just add a register key: 
  [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
    "Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00 
</pre>

<h1 id="toc_13">Foldings</h1>
<pre>
:set foldmethod=
    indent  # indent
    syntax  # syntax highlighting rules
    marker  # markers in the text
    diff    # unchanged text (used in diff views)
    expr    # custom, code-driven folding
    manual  # select ranges to fold (default)
zM za (zc zo) zR     zk zj
zf#j        # creates a fold from the cursor down # lines.
zf/string   # creates a fold from the cursor to string .
zj          # moves the cursor to the next fold.
zk          # moves the cursor to the previous fold.
zo          # opens a fold at the cursor.
zO          # opens all folds at the cursor.
zc          # close fold at the cursor.
zm          # increases the foldlevel by one.
zM          # closes all open folds.
zr          # decreases the foldlevel by one.
zR          # decreases the foldlevel to zero -- all folds will be open.
zd          # deletes the fold at the cursor.
zE          # deletes all folds.
[z          # move to start of open fold.
]z          # move to end of open fold.
:mkview     # save folds
:loadview   # restore folds
</pre>

<h1 id="toc_14">Diff</h1>
<pre>
]c :        # next difference
[c :        # previous difference
Ctrl+w +w   # switch windows
do          # diff obtain
dp          # diff put
zo          # open folded text
zc          # close folded text
:diffget x  # diff obtain from buff that matches x (number or name)
:diffput x  # diff put into buff that matches x (number or name)
:diffupdate # re-scan the files for differences
:diffsplit  # Open a new window on the file {filename}.
:diffthis	# Make the current window part of the diff windows.
:diffoff	# Switch off diff mode for the current window.
:diffoff!	# Switch off diff mode for the current window and in all windows.
</pre>

<h1 id="toc_15">Registers</h1>
<pre>
:reg        # List all registers
"c          # Register 'c'
".          # Last edit
"/          # Last search
":          # Last command
"%          # Filepath
</pre>

<h1 id="toc_16">Text formating</h1>
<p>
If vim knows the comment style of the file then if the next line in insert mode gets comment automatically
</p>

<p>
Often pasting text into vim from an external source screws up the formatting (especially tabs). To prevent this, do:
</p>

<p>
:set paste
</p>

<p>
Keeping this setting on screws up auto indentation while in insert mode, though. So to turn off, use
</p>

<p>
:set nopaste
</p>

<pre>
gq        # formates selected lines to the same length, sensitive to comments. Very useful
:%!fmt    # align all lines
!}fmt     # align all lines at the current position
5!!fmt    # align the next 5 lines
:%retab   # fix spaces/tabs issues in whole file
</pre>

<h1 id="toc_17">Command mode</h1>
<pre>
q/        # Command window for searches
q:        # Command window for commands
</pre>

<h1 id="toc_18">Help and refrences</h1>
<pre>
:viusage  # show a huge cheet sheet lishting every command
</pre>

<h1 id="toc_19">Programming</h1>

<h2 id="toc_19.1">VIM-FUGITIVE (plugin)</h2>
<pre>
:Git      # run a git command
:Gstatus  # git status : - to (un)stage , p to patch, C to commit
:Gcommit  # git commit
:Gread    # empty the buffer and revert to the last commit
:Gwrite   # write the current file and stage the results
:Gmove    # git mv
:Gremove  # git rm
:Glog     # git log
:Gdiff    # perform a vimdiff against the current file of a certain revision
:Gblame   # open blame information in a scroll bound vertical splitt
:Gbrowse  # open github
</pre>


<h1 id="toc_20">TODO</h1>

<p>
Add section for Programming in VIM 
</p>
<ul>
<li>
find functions

<li>
ctag

<li>
quick fix window and make

<li>
work with argdo

</ul>

</body>
</html>
