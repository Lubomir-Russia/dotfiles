%title VIM How to

*VIM Howto*
%toc

= Installation =

Install ruby and ruby-dev beforehand if needed.

== Binary ==
{{{sh
mkdir ~/src
cd ~/src
wget http://ftp.vim.org/pub/vim/unix/vim-7.3.tar.bz2
tar -xaf vim-7.3.tar.bz2
cd vim73
./configure --with-features=huge --enable-perlinterp --enable-rubyinterp --enable-pythoninterp
make
make install
vim --version
}}}
--prefix={directory}  Top directory where to install Vim. Default is /usr/local

== Add plugins ==
* The NERD tree   : A tree explorer plugin for navigating the file system
* project.tar.gz  : Organize/Navigate projects of files (like IDE/buffer explorer) 
* !LustyExplorer  : Dynamic file system and buffer explorer # This plugin requires Vim be compiled with Ruby interpretation.
* !FuzzyFinder    : Buffer/file/command/tag/etc explorer with fuzzy matching 
* bufexplorer.zip : Buffer Explorer / Browser 
* taglist.vim     : Source code browser (supports C/C++, java, perl, python, tcl, sql, php, etc) 
* ack.vim         : Plugin for the Perl module / CLI script 'ack' 

= Saving =
{{{
:w
:w!             # only if permissions allow
:w !sudo tee %  # write as a root
:update         # write only if changed
ZZ              # save file, if modified, and quit (same as ":x")
ZQ              # quit without saving (same as ":q!")
:1,10 w outfile    # Saves lines 1 to 10 in outfile
:1,10 w >> outfile # Appends lines 1 to 10 to outfile
}}}

= Open files and buffers =
{{{
:e filename  # open file in current window
:e .         # browse dir
:ls          # buffers
:bd          # delete (close) buffer
<Ctr>^       # alternative buffer (previous or useful file from plugin)
:b name      # switch to buffer (try TAB and arrows as well)
:b3          # switch to buffer number 3
:bp          # previous buffer
:bn          # next buffer
:bf          # first buffer 
:bl          # last buffer
:ba          # open a window for every buffer (buffer all)
:tab ba      # open a tab for every buffer (buffer all)
:set hidden  # lets hide buffer without saving

:set wildmode=list,full                               # see :h wildmode for details
:e scp://my_user@remote_hostname//path/to/remote/file # open remote file

:bufdo {cmd} # execute {cmd} for each buffers in the buffer list
:windo {cmd} # execute {cmd} for each windows in the current tab page
:tabdo {cmd} # execute {cmd} for each current window of each tab page
:argdo {cmd} # execute {cmd} for each file in the argument list
:r infile    # insert the content of infile
:r !{cmd}    # execute {cmd} and insert its standard output below
}}}

= Tab mappings =
{{{
map <leader>tt :tabnew<cr>        :tabnew                " open a new tab
map <leader>te :tabedit	          :tabe[dit] {file}      " edit {file} in a new tab
map <leader>tc :tabclose<cr>      :tabc[lose]            " close the current tab
map <leader>to :tabonly<cr>       :tabo[nly]             " close the other tabs
map <leader>tn :tabnext<cr>       :tabn[ext]             " go to the next tab
map <leader>tp :tabprevious<cr>   :tabp[revious]         " go to the previous tab
map <leader>tf :tabfirst<cr>      :tabfir[st]            " go to the first tab
map <leader>tl :tablast<cr>       :tabl[ast]             " go to the last tab
map <leader>tm :tabmove	          :tabm[ove] 3           " move the current tab to after tab 3, or the end if no number is given
               :tabs                                     " list the tabs and their windows
}}}

= Windows and Tabs =
{{{
^Ww          # next window.
^WT          # move window to the new tab.
^Wc          # close window.
^Wo          # only this window.
^Wr          # rotate windows.
^Ws          # split windows.
^Wv          # vsplit windows.
^Wx          # swap windows.
^w+          # larger window
^w-          # smaller window
^w=          # equal window
:sp f        # split open f
:vsp f       # vSplit open f
:vert h help # open help in vertical split.
:ta b all    # open all args (input files) in new tabs.
:ta b ball   # open all buffers in new tabs.
:tabm [N]    # move current tab after tab N. No N: last. N=0: first.
$vim -p file1 file2 fileN  # Open multiple files in different tabs.
}}}

= Syntax =
{{{
:syntax enable
:set syntax=perl #force perl syntax on any file type
}}}

= Spelling =
{{{
:set spell
z=       # Suggestions
1z=      # Except the first suggestion
[s       # Next wrong word
]s       # Previous wrong word
zg       # Add as good 
zw       # Add as wrong
zug      # Undo adding as good
zuw      # Undo adding as wrong
}}}

In order to spell check in comments and strings switch off the syntax
{{{
:syntax off
:syntax on
}}}

= Color schema =
* emacs.vim
* far.vim
* murphy.vim
* topfunky-light.vim
* vividchalk.vim
* wombat.vim

= Insert mode =
{{{
I i a A
r R               # backspace will restore the original
cc = C            # change to the end of line
xJ xgJ            # join x lines with/without spaces
x<< x>>           # indent in normal mode
Cntr-t -d         # indent in insert mode
gp                # just like "p", but leave the cursor just after the new text
set tabstop=4
set shiftwidth=4
set expandtab
}}}
#vit = {change, delete, yank, visual} + {all, inner} + {word, Word, sentence, paragraph, tag, ", ', [, {, (}

= Movements =

== motions ==
{{{
0 g0 ^ g^ gE B ge b h gm | l w W e E g$ $
, Fx Tx fx Tx  ;
gg xH { ( gk - k M j + gj ) } xL G          # 12gg = 12G
Ctrl-b Ctrl-u Ctrl-y Ctrl-e Ctrl-d Ctrl-f
zt (z Enter) zz zb # set scrolloff=3 to have some extra lines for a lookup
zH zh zl zL
gCtrl-g # where am I? also set ruler set number set laststatus=2
}}}
When a motion is not of the type you would like to use, you can force another
type by using "v", "V" or CTRL-V just after the operator.

== :marks ==
{{{
ma `a 'a # local marks used for navigation and block editing
mA `A 'A # global marks can be used as short cuts to often used files
`0-`9    # most recent exited files
]'  ['   # [count] times to next/previous line with a lowercase mark below
]`  [`   # [count] times to lowercase mark after/before the cursor. 
`"       # [count] times to lowercase mark before the cursor.
}}}

== :jumps ==
A "jump" is one of the following commands: "'", "`", "G", "/", "?", "n",
"N", "%", "(", ")", "]]", "[[", "{", "}", ":s", ":tag", "L", "M", "H" and
the commands that start editing a new file.
{{{
'' ``    # latest jump
^O       # older cursor position in jump list (not a motion command)
^I       # newer cursor position in jump list (not a motion command)
<Tab>    # newer cursor position in jump list (not a motion command)
%        # jump to match, also see plugins
o O      # jump in visual mode to the other end of selection
`"       # jump to position on which we were when exited current buffer last time. 
`0       # jump to position in last file edited (when exited Vim)
`1       # like `0 but the previous file (also `2 etc)
}}}

== :changes ==
{{{
'. `.    # latest edit
gi       # latest edit and insert
`[ `]    # jump to the first/last character of the previously changed or yanked text. 
'[  ']   # jump to the first/last line of the previously changed or yanked text. 
`< `>    # jump to beginning/end of last visual selection
g;       # older cursor position in change list (not a motion command)
g,       # newer cursor position in change list (not a motion command)
}}}

= Searching and Substitutions =

== Search settings ==
{{{
:set hlsearch
:set incsearch
:set number
}}}

== Searching ==
{{{
g# # N ? / n * g*

]I                   # list lines in current and included files that contain the word under cursor, 
[I                   # start searching at cursor position the cursor/beginning of current file.
gd gD                # find local/global declaration
/pattern/+           # next line
/pattern/+x          # x lines after
/pattern/e+x         # x characters after
/\< the\>            # search the
/^\n\{3}             # find 3 empty lines
:bufdo /searchstr/   # search in all open files
}}}

== Substitutions ==
{{{
:[range] s/pattern/string/[flags] [count]  # substitute
   #flags g, c, i, I
   #ranges , joins ; separates, also use visual
   empty             # current line
   %                 # all buffer
   +x -x             # x lines up/down
   1                 # first line
   $                 # last line
   't                # mark 't
   /pat/             # pattern
   #count            # only in the next x lines
   /\cpatter         # case insensitive
   /\Cpatter         # case sensitive
}}}
{{{
:%s/\<./\u&/g        # Sets first letter of each word to uppercase
:%s/\<./\l&/g        # Sets first letter of each word to lowercase
:%s/.*/\u&           # Sets first letter of each line to uppercase
:%s/.*/\l&           # Sets first letter of each line to lowercase
}}}

== Grep ==
{{{
:[range] g/pattern/[cmd] #search and execute
   #                 # show lines with numbers
   d                 # delete lines
   y                 # yank lined
   /normal {command} # execute an extended sequence, examples:
          :g/^$/d                               delete empty lines
          :g/pat/+ y                            copy lines after match
          :.,+10g/pat/d                         delete lines with pat within next 10 lines
          :.,'f+2g/pat/#                        show lines with pat from here to mark f +2 lines
          :.,/pat1/g/pat2/d                     delete lines with pat1 from here to line with pat2
          :g/^sub /normal O# This sub is for    adds this line before all sub definitions
          :g/pat                                list all lines that have pat
Tip: last search is in register /. To copy it into command: <Ctrl-r>/. So firstly tune your search with inc-search and then copy it to g/<Ctrl-r/d
}}}

== Regular expression syntax style == 
{{{
\v      # very magic =~ Perl = Unix Egrep, but '=' is 0 or 1 match (in Perl it is '?')  /\v(.y){3}
\m      # magic = default = Unix grep => \( \) \+ \= *   /\(.y\)\{3}
}}}

== Action with searching ==
{{{
#vit = {change, delete, yank, visual} + {?pat,/pat} + {?+,?+x,?-,?-x,/+,... }

:%perldo s/this/that/ # execs that perl s///
}}}

= Mapping and abbreviation =
{{{
map namp imap vmap map!
:map :vmap :map >               # show current mappings all/ for > only
:vumap > :unmap >               # unmap >
:vmap > >gv                     # indent block without losing selection
:vmap < <gv
:vmap <Tab> >gv
:vmap <S-Tab> <gv
:imap <Tab> <C-N>
:imap <S-Tab> <C-P>
:nnoremap ; :                   # swapping keys
:nnoremap : ;
:let mapleader=","              # change the personal hotkey
:imap <Leader>f <Esc>gUiw`]a    # capitalize current word in insert mode

:ab ff FireFox                  # insert, command and replace mode
}}}
To avoid the abbreviation in insert mode: Type part of the abbreviation, exit
insert mode with <Esc>, re-enter insert mode with "a" and type the rest.  Or
type CTRL-V before the character after the abbreviation.
To avoid the abbreviation in Command-line mode: Type CTRL-V twice somewhere in
the abbreviation to avoid it to be replaced.  A CTRL-V in front of a normal
character is mostly ignored otherwise.
{{{
Remap CapsLock to Ctrl: in Windows just add a register key: 
  [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
    "Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00 
}}}

= Foldings =
{{{
:set foldmethod=
    indent  # indent
    syntax  # syntax highlighting rules
    marker  # markers in the text
    diff    # unchanged text (used in diff views)
    expr    # custom, code-driven folding
    manual  # select ranges to fold (default)
zM za (zc zo) zR     zk zj
zf#j        # creates a fold from the cursor down # lines.
zf/string   # creates a fold from the cursor to string .
zj          # moves the cursor to the next fold.
zk          # moves the cursor to the previous fold.
zo          # opens a fold at the cursor.
zO          # opens all folds at the cursor.
zc          # close fold at the cursor.
zm          # increases the foldlevel by one.
zM          # closes all open folds.
zr          # decreases the foldlevel by one.
zR          # decreases the foldlevel to zero -- all folds will be open.
zd          # deletes the fold at the cursor.
zE          # deletes all folds.
[z          # move to start of open fold.
]z          # move to end of open fold.
:mkview     # save folds
:loadview   # restore folds
}}}

= Diff =
{{{
]c :        # next difference
[c :        # previous difference
Ctrl+w +w   # switch windows
do          # diff obtain
dp          # diff put
zo          # open folded text
zc          # close folded text
:diffget x  # diff obtain from buff that matches x (number or name)
:diffput x  # diff put into buff that matches x (number or name)
:diffupdate # re-scan the files for differences
:diffsplit  # Open a new window on the file {filename}.
:diffthis	# Make the current window part of the diff windows.
:diffoff	# Switch off diff mode for the current window.
:diffoff!	# Switch off diff mode for the current window and in all windows.
}}}

= Registers =
{{{
:reg        # List all registers
"c          # Register 'c'
".          # Last edit
"/          # Last search
":          # Last command
"%          # Filepath
}}}

= Text formating =
If vim knows the comment style of the file then if the next line in insert mode gets comment automatically

Often pasting text into vim from an external source screws up the formatting (especially tabs). To prevent this, do:

:set paste

Keeping this setting on screws up auto indentation while in insert mode, though. So to turn off, use

:set nopaste

{{{
gq        # formates selected lines to the same length, sensitive to comments. Very useful
:%!fmt    # align all lines
!}fmt     # align all lines at the current position
5!!fmt    # align the next 5 lines
:%retab   # fix spaces/tabs issues in whole file
}}}

= Command mode =
{{{
q/        # Command window for searches
q:        # Command window for commands
}}}

= Help and refrences =
{{{
:viusage  # show a huge cheet sheet lishting every command
}}}

= Programming =

== VIM-FUGITIVE (plugin) ==
{{{
:Git      # run a git command
:Gstatus  # git status : - to (un)stage , p to patch, C to commit
:Gcommit  # git commit
:Gread    # empty the buffer and revert to the last commit
:Gwrite   # write the current file and stage the results
:Gmove    # git mv
:Gremove  # git rm
:Glog     # git log
:Gdiff    # perform a vimdiff against the current file of a certain revision
:Gblame   # open blame information in a scroll bound vertical splitt
:Gbrowse  # open github
}}}


= TODO =

Add section for Programming in VIM 
* find functions
* ctag
* quick fix window and make
* work with argdo
